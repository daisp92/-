/*猜数字游戏的提示
 * 给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。
 * 输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束，n=0时输入结束。
 * 样例输入：
 * 4
 * 1 3 5 5
 * 1 1 2 3
 * 4 3 3 5
 * 6 5 5 1
 * 6 1 3 5
 * 1 3 5 5
 * 0 0 0 0
 * 10
 * 1 2 2 2 4 5 6 6 6 9
 * 1 2 3 4 5 6 7 8 9 1
 * 1 1 2 2 3 3 4 4 5 5
 * 1 2 1 3 1 5 1 6 1 9
 * 1 2 2 5 5 5 6 6 6 7
 * 0 0 0 0 0 0 0 0 0 0
 * 0
 * 样例输出：
 * Game 1:
 *     (1,1)
 *     (2,0)
 *     (1,2)
 *     (1,2)
 *     (4,0)
 * Game 2:
 *     (2,4)
 *     (3,2)
 *     (5,0)
 *     (7,0)
 */
#include <stdio.h>
#define maxn 1010 //输入数组的最大范围

int main() {
    int n,a[maxn],b[maxn]; //n为Game n; a[]表示答案数组；b[]猜测数组
    while(scanf("%d",&n)==1 && n) //当n有输入，而且n不为0，循环继续；输入game n；
    {
        for (int i = 0; i < n; ++i) {  //输入答案数组
            scanf("%d",&a[i]);
        }
        for (; ; ) { //循环输入猜测数组，直到猜测序列为0时，跳出循环；
            int A=0,B=0;  //A为有多少数字位置正确；B为统计数字在两个序列都出现过但位置不对。
            for (int i = 0; i < n; ++i) { //输入猜测序列，并判断有多少数字位置正确。
                scanf("%d",&b[i]);
                if(a[i]==b[i]) A++;
            }
            if (b[0]==0) break;  //当输入猜测序列为0时，跳出循环。正常的序列不会有0，所以只判断第一个数是否为0即可
            for (int d = 1; d <=9 ; ++d) { //为了求B，对于每个数字1-9，统计a/b数组出现的次数c1和c2，min(c1,c2)就是该数字
                // 对B的贡献，最后要减去A的部分
                int c1=0,c2=0;
                for (int i = 0; i < n; ++i) {
                    if (a[i]==d) c1++;
                    if (b[i]==d) c2++;
                }
                if (c1<c2) B+=c1; else B+=c2;
            }
            printf("    (%d,%d)\n",A,B-A);
        }
    }
    return 0;
}